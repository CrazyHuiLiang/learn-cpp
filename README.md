# Learn c++

## 数据类型

### 程序中的数据

* 常量
* 变量

### 整数类型

* 基本整数类型 int
* 符号 (signed)
* 无符号(unsigned)
* short
* long
* long long

### 浮点数类型

* 单精度 float
* 双精度 double
* 扩展精度 long double

### 字符类型

* char

### 字符串类型

* 有字符串常量
* 基本类型中没有字符串变量
  * 采用字符数组存储字符串（c风格的字符串） 不推荐使用
* 标准c++类库中的String类（c++风格的字符串）

### 布尔类型

* true、false


## 函数

### 声明

```
类型标识符 被调用的函数名( 含类型说明的形参表 )
```

### 调用
```
函数名( 实参列表 )
```

## 类


### 构造

* 首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。
* 成员对象构造函数调用顺序：按对象成员的声明顺序，先声明者先构造。
* 初始化列表中未出现的成员对象，调用用默认构造函数（即无形参的）初始化
* 处理完初始化列表之后，再执行构造函数的函数体。

### 复制构造函数被调用的三种情况

* 定义一个对象时，以本类另一个对象作为初始值，发生复制构造；
* 如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；
* 如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名对象，传递给主调函数，此时发生复制构造。
  * 这种情况也可以通过移动构造避免不必要的复制


### UML

* 事物
* 关系
* 图


## 数据的共享与保护

### 作用域分类

* 函数原型作用域
* 局部作用域(块作用域)
* 类作用域
* 文件作用域
* 命名空间作用域


### 对象的生存期

#### 静态生存期

* 与程序的运行期相同


#### 动态生存期

* 开始于程序执行到声明点，结束于所处的块

### C++程序的一般组织结构

* 一个工程可以划分为多个源文件，例如：
  * 类的声明文件（.h文件: 系统类库中的头文件通常不带后缀.h,我们自己写的通常带后缀.h)
  * 类的实现文件（.cpp文件）
  * 类的使用文件(main()所在的.cpp文件)
* 利用工程来组合各个文件



### 继承与派生

* 继承与派生是同一过程从不同的角度看
  * 保持已有类的特性而构造新类的过程称为继承
  * 在已有类的基础上新增自己的特性而产生新类的过程称为派生


单继承时派生类的定义

```
class 派生类名: 继承方式 基类名 {
  成员声明;
}

例如
class Derived: public Base {
  public:
    Derived();
    ~Derived();
};
```

多继承时派生类的定义

```
语法

class 派生类名: 继承方式1 基类名1, 继承方式2 基类名2, ...
{
  成员声明;
}


注意： 每一个“继承方式”，只用于限制对紧随其后之基类的继承。

例如:
class Derived: public Base1, private Base2 {
  public:
    Derived();
    ~Derived();
};
```

不同继承方式的影响主要体现在：
* 派生类`成员`对基类成员的访问权限
* 通过派生类`对象`对基类成员的访问权限



* 共有继承(public)
  * 继承的访问控制
    * 基类的public和protected成员：访问属性在派生类中保持不变
    * 基类的private成员：不可直接访问
  * 访问权限
    * 派生类中的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员
    * 通过派生类的对象：只能访问public成员
* 私有继承（private）
  * 继承的访问控制
    * 基类的public和protected成员: 都以private身份出现在派生类中；
    * 基类的private成员: 不可直接访问
  * 访问权限
    * 派生类中成员函数: 可以直接访问基类中的public和protected成员，但不能直接访问基类中的private成员
    * 通过派生类的对象: 不能直接访问从基类继承的任何成员
* 保护继承（protected）
  * 继承的访问控制
    * 基类的public和protected成员: 都以protected身份出现在派生类中
    * 基类的private成员: 不可直接访问
  * 访问权限
    * 派生类中的成员函数： 可以直接访问基类中的public和protected成员，但不能直接访问private成员
    * 通过派生类的对象：不能直接访问从基类继承的任何成员


类型转换

* 共有派生类对象可以被当做基类的对象使用，反之则不可
  * 派生类的对象可以隐含转换为基类对象
  * 派生类的对象可以初始化基类的引用
  * 派生类的指针可以隐含转换为基类的指针
* 通过基类对象名、指针只能使用从基类继承的成员



#### 继承基类的构造函数

可用using语句继承基类构造函数，但是只能初始化从基类继承的成员；语法形式 using B::B;

单继承时构造函数的定义语法

``` 
  派生类名::派生类名(基类所需形参， 本类成员所需的形参): 基类名(参数表), 本类成员初始化列表
  {
      // 其他初始化
  }；
```

多继承时构造函数的定义语法
```
派生类名::派生类名(参数表): 基类名1(基类1初始化参数表), ... 基类名n(基类n初始化参数表), 本类成员初始化列表 {
	// 其他初始化;
};
```
  
多继承且有对象成员时派生的构造函数定义语法
```
派生类名::派生类名(形参表): 基类名1(参数), ... 基类名n(参数), 本类成员(含对象成员) 初始化列表
{
	// 其他初始化
};


构造函数的执行顺序
1. 调用基类构造函数；顺序按照他们被继承时声明的顺序（从左向右)
2. 对初始化列表中的成员进行初始化
	1. 顺序按照他们在类中定义的顺序
	2. 对象成员初始化时自动调用其所属类的构造函数
		1. 由初始化列表提供参数
3. 执行派生类的构造函数体中的内容
```

若派生类没有声明复制构造函数

* 编译器会在需要时生成一个隐含的复制构造函数
* 先调用基类的复制构造函数
* 再为派生类新增的成员执行复制

若派生类定义复制构造函数

* 一般都要为基类的复制构造函数传递参数
* 复制构造函数只能接受一个参数，既用来初始化派生类定义的成员，也将被传递给基类的复制构造函数
* 基类的复制构造函数形参类型是基类对象的引用，实参可以是派生类对象的引用
* 例如： C::C(const C &c1): B(C1) {...}


派生类的析构函数

* 析构函数不被继承，派生类如果需要，要自行声明析构函数
* 声明方法与无继承关系时类的析构函数相同
* 不需要显式地调用基类的析构函数，系统会自动隐式调用
* 先执行派生类析构函数的函数体，再调用基类的析构函数


当派生类与基类中有相同成员时：

* 若未特别限定，则通过派生类对象使用的是派生类的同名成员
* 如果要通过派生类对象访问基类中被隐藏的同名成员，应使用基类名和作用域操作符(::)来限定


### 虚基类

需要解决的问题： 当派生类从多个基类派生，而这些基类又有公共基类，则在访问此公共基类中的成员时，将产生冗余，并有可能冗余带来不一致性

虚基类声明: 以virtual说明基类继承方式
例如： class B1: virtual public B

作用：

* 主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题
* 为最远的派生类提供唯一的基类成员，而不重复产生多次复制

注意：在第一级继承时就要将公共基类设计为虚基类

#### 虚基类及其派生类构造函数

* 建立对象时所指定的类称为最远派生类
* 虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的
* 在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中为虚基类的构造函数列出参数。如果未列出，则表示调用该虚基类的默认构造函数
* 在建立对象时，只有最远派生类的构造函数调用虚基类的构造函数，其他类对虚基类构造函数的调用被忽略


### 重载

* 重载为类的非静态成员函数
* 重载为非成员函数


重载为类成员的运算符函数定义形式：
```
函数类型 operator 运算符(形参) {
  ...
}
参数个数 = 原操作数个数 - 1(后置++， --除外)
```

双目运算符重载规则

* 如果要重载B为类成员函数，使之能够实现表达式 opr1 B opr2,其中opr1为A类对象，则B应被重载为A类的成员函数，形参类型应该是opr2所属的类型。
* 经过重载后，表达式opr1 B opr2相当于opr1.operator B(opr2)

前置单目运算符重载规则

* 如果要重载U为类成员函数，使之能够实现表达式U oprd，其中oprd为A类对象，则U应该被重载为A类的成员函数，无形参。
* 经重载后，表达式U oprd相当于oprd.operator U()

后置单目运算符 ++和--重载规则

* 如果要重载++或者--为类成员函数，使之能够实现表达式oprd++或oprd--， 其中oprd为A类对象，则++或--应被重载为A类的成员函数，且具有一个int类型形参。
* 经重载后，表达式 oprd++相当于 oprd.operator ++(0)


运算符重载为非成员函数的规则

* 函数的形参代表依自左至右次序排列的各操作数
* 重载为非成员函数
  * 参数个数=原操作数个数（后置++、 --除外）
  * 至少应该有一个自定义类型的参数
* 后置单目运算符++和--的重载函数，形参列表中要增加一个int，但不必写形参名
* 如果在运算符的重载函数中需要操作某类对象的私有成员，可以将此函数声明为该类的友元

```
双目运算符 B重载后，表达式oprd1 B oprd2 等同于 operator B(oprd1, oprd2)
前置单目运算符 B重载后，表达式B oprd 等同于 operator B(oprd)
后置单目运算符++和--重载后，表达式oprd B 等同于operator B(oprd, 0)
```


### 虚函数

使用virtual描述的函数在编译时不会确定调用的指向，调用对象会延迟至运行时确定

* 用virtual关键字说明的函数
* 虚函数是实现运行时多态性基础
* c++ 中的虚函数是动态绑定的函数
* 虚函数必须是非静态的成员函数，虚函数经过派生之后，就可以实现运行过程中的多态

什么函数可以是虚函数

* 一般成员函数可以是虚函数
* 构造函数不能是虚函数
* 析构函数可以是虚函数

一般虚函数成员

* 虚函数声明
  * virtual 函数类型 函数名(形参表);
* 虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候
* 在派生类中可以对基类中的成员函数进行覆盖
* 虚函数一般不声明为内联函数，因为对虚函数的调用需要动态绑定，而对内联函数的处理是静态的

virtual 关键字

* 派生类可以不显式地用virtual声明虚函数，这时系统就会用以下规则来判断派生类的一个函数成员是不是虚函数
  * 该函数是否与基类的虚函数有相同的名称、参数个数及对应参数类型；
  * 该函数是否与基类的虚函数有相同的返回值或者满足类型兼容规则的指针、引用型的返回值
* 如果从名称、参数及返回值三个方面检查之后，派生类的函数满足上述条件，就会自动确定为虚函数。这时，派生类的虚函数便覆盖了基类的虚函数
* 派生类中虚函数还会隐藏基类中同名函数的所有其他重载形式
* 一般习惯于在派生类的函数中也使用virtual关键字，以增加程序的可读性

#### 虚析构函数

如果你打算允许其他人通过基类指针调用对象的析构函数（通过delete这样做是正常的），就需要让基类的析构函数成为函数，否则执行delete的结果是不确定的。

#### 虚表

* 每个多态类有一个虚表（virtual table）
* 虚表中有当前类的各个虚函数的入口地址
* 每个对象有一个指向当前类的虚表的指针（虚指针vptr）

#### 动态绑定的实现

* 构造函数中为对象的虚指针赋值
* 通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址
* 通过该入口地址调用虚函数


#### 纯虚函数

是一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容，要求各派生类根据实际需要定义自己的版本，纯虚函数的声明格式为：

```
virtual 函数类型 函数名(参数表) = 0;
```

#### 抽象类的语法

带有纯虚函数的类称为抽象类

```
class 类名 {
  virtual 类型 函数名(参数表)=0;
}
```

* 抽象类的作用
  * 将有关数据的行为组织在一个继承层次结构中，保证派生类具有要求的行为
  * 对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类实现
* 需要注意
  * 抽象类只能作为基类来使用
  * 不能定义抽象类的对象

#### override

* 多态行为的基础： 基类声明虚函数，派生类声明一个函数覆盖该虚函数
* 覆盖要求：函数签名（signature）完全一致
* 函数签名包括：函数名 参数列表 const


override可以强制同名函数需要和基类同名函数的函数签名保持一致：c++11 引入显式函数覆盖，在编译期而非运行期捕获此类错误。在虚函数显式重载中运用，编译器会检查基类是否存在一虚拟函数，与派生类中带有声明override的虚拟函数，有相同的函数签名（signature）；若不存在，则会报错

#### final

声明类不允许被继承


## 模板与群体数据

### 函数模板

定义语法

```
语法形式：
  template <模板参数表>
  函数定义
模板参数表的内容
  * 类型参数： class/typename 标识符
  * 常量参数： 类型说明符 标识符
  * 模板参数： template <参数表> class 标识符
  
```

* 一个函数模板并非自动可以处理所有类型的数据
* 只有能够进行函数模板中运算的类型，可以作为类型实参
* 自定义的类，需要重载模板中的运算符，才能作为类型实参

### 类模板

可以为类声明一种模式，使得类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值，能取任意类型（包括基本类型和用户自定义类型）

* 类模板

```
  template <模板参数表>
  class类名
  {类成员声明}
  
模板类以外定义其成员函数的形式：
  template  <模板参数表>
  类型名 类名<模板参数标识符列表>::函数名(参数表)
```

## 线性群体

### 数组

* 静态数组
  * 有固定元素个数的群体，其中元素可以通过下标直接访问
  * 大小在编译时就已经确定，运行时无法修改
* 动态数组
  * 一系列位置连续，任意数量相同类型的元素组成
  * 其元素个数可在程序运行时改变



## 泛型程序设计

泛型程序设计的基本概念

* 编写不依赖于具体数据类型的程序
* 将算法从特定的数据结构中抽象出来，成为通用的
* C++的模板为泛型程序设计奠定了关键的基础

* 用来界定具备一定功能的数据类型。例如：
  * 将“可以比大小的所有数据类型（有比较运算符）”这一概念记为Comparable
  * 将“具有公有的复制构造函数并可以用‘=’赋值的数据类型”这一概念记为Assignable
  * 将“可以比大小、具有公有的复制构造函数并可以用‘=’赋值的所有数据类型”这个概念记作Sortable
* 对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能，那么就说概念B是概念A的子概念。例如：
  * Sortable既是Comparable的子概念，也是Assignable的子概念


### STL

标准模板库（Standard Template Library，简称STL）提供了一些非常常用的数据结构和算法

* STL的基本组件
  * 容器（container）
  * 迭代器（iterator）
  * 函数对象（function object）
  * 算法（algorithms）

![](http://sc0.ykt.io/ue_i/20200308/1236659027212111872.png)


迭代器的分类

![](http://sc0.ykt.io/ue_i/20200308/1236659800931176448.png)

![](http://sc0.ykt.io/ue_i/20200308/1236661217511215104.png)

![](http://sc0.ykt.io/ue_i/20200308/1236661238482735104.png)












## 输入输出流

程序与外界环境进行信息交换时存在两个对象：

* 程序中的对象
* 文本对象

流是一种抽象，负责数据的生产者和数据的消费者之间建立联系，并管理数据的流动。


![流](https://qn-next.xuetangx.com/15659274391778.png)

![](https://qn-next.xuetangx.com/15659274423015.png)


### 输出流

预先定义的输出流对象

* cout 标准输出
* cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出
* clog 类似于cerr，但是有缓冲，缓冲区满时被输出

构造输出流对象

* ofstream类支持磁盘文件输出
* 如果在构造函数中指定一个文件名，当构造这个文件时该文件是自动打开的
	* ofstream myFile("filename")
* 可以调用默认构造函数之后使用open成员函数打开文件
	* ofstream myFile; // 声明一个静态文件输出流对象
	* myFile.open("filename"); // 打开文件，使流对象与文件建立联系
* 在构造对象或用open打开文件时可以指定模式
	* ofsteam myFile("filename", ios_base::out | ios_base::binary);

文件输出流成员函数的三种类型

* 与操作符等价的成员函数
* 执行非格式化写操作的成员函数
* 其他修改流状态且不同于操作符或插入运算符的成员函数

文件输出流成员函数

* open()
	* 把流与一个特定的磁盘文件关联起来
	* 需要制定打开模式
* put()
	* 把一个字符串写到输出流中
* write()
	* 将内存中的一块内容写到一个文件输出流中
* seekp() 和 tellp()
	* 操作文件流的内部指针
* close()
	* 关闭一个文件输出流关联的磁盘文件
* 错误处理函数
	* 在写到一个流时进行错误处理


向文本文件输出

* 插入（<<）运算符
	* 操纵符：控制输出格式
	* 定义位置： ios_base类、`<iomanin>`
	* setw() 设置输出宽度
	* dec(),oct(),hex() 输入输出的默认进制

setiosflags() 操纵符

* 定义在ismanip中
* 不用于width和setw，他的影响是持久的，直到用resetiosflags重新恢复默认值时为止
* 参数是该流的格式标志值，可以按为或(|) 运算符进行组合

精度

* 如果不指定fixed或scientific，精度值表示有效数字位数
* 如果设置了ios_base::fixed 或 ios_base::scientific精度值表示小数点之后的位数


二进制文件流

* 使用ofstream构造函数中的模式参量指定二进制输出模式
* 已通常方式构造一个流，然后使用setmode成员函数，在文件打开后改变模式

字符串输出流

* 用于构造字符串（ostringstream）
* 功能
	* 支持ofsteam类的除open close外的所有操作
	* str函数可以返回当前已构造的字符串
* 典型应用
	* 将数值转换为字符串


输入流类：

* istream类最适合用于顺序文本模式输入。 cin是其实例
* ifstream 类支持磁盘文件输入
* istringstream



构造输入流对象

* ifstream类支持磁盘文件输入
* 如果在构造函数中指定一个文件名，当构造这个文件时该文件是自动打开的
	* ifstream myFile("filename")
* 可以调用默认构造函数之后使用open成员函数打开文件
	* ifstream myFile; // 声明一个静态文件输出流对象
	* myFile.open("filename"); // 打开文件，使流对象与文件建立联系
* 在构造对象或用open打开文件时可以指定模式
	* ifsteam myFile("filename", ios_base::in | ios_base::binary);


使用提取运算符从文本文件输入

* 提取运算符(>>)对于所有标准c++数据类型都是预先设计好的
* 是从一个输入流对象获取字节最容易的方法
* ios类中的很多操纵符都是可以应用于输入流。但是只有少数几个对输入流对象具有实际影响，其中最重要的是进制操纵符dec、oct和hex

输入流相关函数

* open 把该流与一个特定磁盘文件相关联。
* get 功能与提取运算符（>>）很相像，主要的不同点是get函数在读入数据时包括空白字符。
* getline 功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成后，从读取的内容中删除终止字符。
* read 从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。
* seekg 用来设置文件输入流中读取数据位置的指针。
* tellg 返回当前文件读指针的位置。
* close 关闭与一个文件输入流关联的磁盘文件。 


从字符串输入, 将字符串作为文本输入流的源，可以将字符串转换为其他数据类型

* 字符串输入流（ istringstream）
* 用于从字符串读取数据
* 在构造函数中设置要读取的字符串
* 支持ifstream类的除open、close外的所有操作
* 典型应用
	* 将字符串转换为数值 

两个重要的输入/输出流

* 一个iostream对象可以是数据的源或目的。
* 两个重要的I/O流类都是从iostream派生的，它们是fstream和stringstream。这些类继承了前面描述的istream和ostream类的功能。 
fstream类

* fstream类支持磁盘文件输入和输出。
* 如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个fstream对象。
* 一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出。 
stringstream类

* stringstream类支持面向字符串的输入和输出
* 可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成。 

## 异常处理

![](http://sc0.ykt.io/ue_i/20200308/1236682439804456960.png)


```
抛掷异常
throw 表达式;

捕获
try {
}
catch(int e) {
}
catch(int e) {
}
```

异常接口声明
void fun() throw(A, B, C, D);



异常处理中的构造与析构

* 自动的析构
	* 找到一个匹配的catch异常处理后
		* 初始化异常参数。
		* 将从对应的try块开始到异常被抛掷处之间构造（且尚未析构）的所有自动对象进行析构。
	* 从最后一个catch处理之后开始恢复执行。 
标准异常类的继承关系

![](http://sc0.ykt.io/ue_i/20200309/1236683751526895616.png)

C++标准库各种异常类所代表的异常

![](http://sc0.ykt.io/ue_i/20200309/1236683802936479744.png)

标准异常类的基础
	
* exception：标准程序库异常类的公共基类
* logic_error表示可以在程序中被预先检测到的异常
    * 如果小心地编写程序，这类异常能够避免
* runtime_error表示难以被预先检测的异常 


